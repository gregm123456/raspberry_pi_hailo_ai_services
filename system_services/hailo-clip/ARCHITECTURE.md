# Hailo CLIP Service Architecture

## Purpose

Deploy CLIP zero-shot image classification as a managed systemd service on Raspberry Pi 5 + Hailo-10H, exposing a REST API on port 5000 for runtime-configurable image-to-text classification.

## High-Level Design

```
systemd: hailo-clip.service
 ├─ ExecStart: python3 /opt/hailo-clip/hailo_clip_service.py
 ├─ User: hailo-clip
 ├─ Config: /etc/hailo/hailo-clip.yaml (YAML) → /etc/xdg/hailo-clip/hailo-clip.json (JSON)
 ├─ State: /var/lib/hailo-clip/ (models, cache, temp)
 └─ XDG variables for config/data location discovery
```

## Components

### 1. Installation (`install.sh`)

**Responsibilities:**
- Validate Hailo driver, Python environment, hailo-apps availability
- Create `hailo-clip` system user/group
- Add user to device group for `/dev/hailo0` access
- Create state directories with correct permissions
- Install systemd unit
- Render YAML config to JSON
- Verify service startup and health

**Idempotency:**
- Safe to run multiple times
- Preserves existing config (doesn't overwrite `/etc/hailo/hailo-clip.yaml`)
- Reloads systemd daemon on each run

### 2. Systemd Unit (`hailo-clip.service`)

**Type:** `simple` (Python service does not call `sd_notify`)

**Key Directives:**
- `StateDirectory=hailo-clip` → Ensures `/var/lib/hailo-clip` exists and is owned by `hailo-clip:hailo-clip`
- `XDG_CONFIG_HOME=/etc/xdg` → Service reads config from `/etc/xdg/hailo-clip/hailo-clip.json`
- `XDG_DATA_HOME=/var/lib` → Service writes models/cache to `/var/lib/hailo-clip/`
- `MemoryMax=3G` → Cap memory to 3 GB (tunable for resource-constrained deployments)
- `CPUQuota=80%` → Cap CPU to 80% of one core (prevents thermal throttle on sustained load)
- `TimeoutStartSec=120` → Extended startup timeout for model loading
- `Restart=always` → Auto-restart on crash

**Device Access:**
- Service user inherits device group membership (added during install)
- Allows access to `/dev/hailo0` for NPU

### 3. Python Service (`hailo_clip_service.py`)

**Architecture:**
```
CLIPServiceConfig (YAML loader)
    ↓
CLIPModel (Hailo CLIP wrapper)
    ├─ load() → Initialize hailo-apps CLIP
    ├─ encode_image() → Image → 640-dim embedding
    ├─ encode_text() → Text → 640-dim embedding
    └─ cosine_similarity() → Compute matching scores
    ↓
Flask REST API
    ├─ /health (GET)
    ├─ /v1/classify (POST)
    ├─ /v1/embed/image (POST)
    └─ /v1/embed/text (POST)
```

**Key Features:**

- **Thread-safe embedding:** `CLIPModel.lock` (RLock) serializes model access
- **Lazy loading:** Model loaded on first request if not pre-loaded
- **Mock fallback:** If hailo-apps import fails, uses random embeddings (for testing/fallback)
- **Cosine similarity:** All embeddings normalized; similarity = dot product
- **Signal handling:** Graceful shutdown on SIGTERM

**Configuration Loading:**
1. Read `/etc/hailo/hailo-clip.yaml`
2. Fallback to defaults if missing
3. Validate and apply config to Flask app

**Signal Handling:**
```python
signal.signal(signal.SIGTERM, signal_handler)
signal.signal(signal.SIGINT, signal_handler)
```
Ensures graceful shutdown on systemd stop.

### 4. Configuration Management

**YAML Config** (`/etc/hailo/hailo-clip.yaml`):
```yaml
server:
  host: 0.0.0.0
  port: 5000

clip:
  model: clip-resnet-50x4
  embedding_dimension: 640
  device: 0
  image_size: 224
```

**JSON Config** (`/etc/xdg/hailo-clip/hailo-clip.json`):
- Auto-generated by `render_config.py` from YAML
- Validates required fields, applies defaults
- Read by service on startup

**Config Rendering Script** (`render_config.py`):
- Loads YAML with validation
- Ensures required keys present
- Outputs JSON with defaults applied
- Safe to call multiple times

## Resource Model

### Memory Budget

| Component | Typical | Peak |
|-----------|---------|------|
| CLIP model | 1-2 GB | 1-2 GB |
| Flask/Python runtime | 100-200 MB | 200-300 MB |
| Request buffers | 50-100 MB | 100-200 MB |
| **Total systemd limit** | 3 GB | 3 GB |

**Concurrency with other services:**
- `hailo-ollama` (LLM): 2-4 GB
- `hailo-vision` (other vision): 1-2 GB
- **Total possible:** 4-8 GB (fits within Pi 5's ~5-6 GB usable)

### CPU Impact

- Embedding computation: GPU-offloaded to Hailo-10H
- Flask request handling: Minimal CPU (request parsing, JSON serialization)
- `CPUQuota=80%` prevents runaway on edge cases

### Thermal Management

- Hailo-10H inference: Minimal thermal impact (optimized silicon)
- Pi 5 CPU: 80% quota prevents sustained thermal throttling
- Passive cooling typically sufficient; active cooling recommended for continuous 24/7 operation

## Constraints

1. **Single device:** `/dev/hailo0` must be present; no multi-device support
2. **Model persistence:** Models stay loaded in VRAM; unload only on service stop
3. **Embedding dimension:** Fixed 640-dim vectors (ResNet-50x4 specific)
4. **Image input:** Fixed 224×224 canvas (automatic resize/pad in model)
5. **Concurrency:** Flask multithreading with lock serializes GPU access

## API Design

**REST conventions:**
- `GET /health` → Service status (non-blocking probe)
- `POST /v1/classify` → Image classification (main workload)
- `POST /v1/embed/{image,text}` → Raw embeddings (advanced users)

**Request Format:** JSON with base64-encoded images (avoids multipart complexity)

**Response Format:** JSON with consistent `{"result": ..., "inference_time_ms": ...}` pattern

## Deployment Flow

1. **Installer runs:**
   - Checks Hailo driver, Python, hailo-apps availability
   - Creates user/group, state directories
   - Installs systemd unit
   - Renders config YAML→JSON
   - Verifies service health

2. **Service starts via systemd:**
   - Loads config from `/etc/hailo/hailo-clip.yaml`
   - Initializes CLIPModel (loads from hailo-apps)
   - Starts Flask on configured port
   - Ready for requests

3. **On request:**
   - Service decodes image, encodes with CLIP
   - Encodes text prompts
   - Computes cosine similarities
   - Returns top-k matches

4. **On config change:**
   - Operator edits `/etc/hailo/hailo-clip.yaml`
   - Runs `render_config.py` (done by install.sh if re-run)
   - Restarts service: `sudo systemctl restart hailo-clip.service`

## Future Improvements

1. **Warmup model loading:** Pre-load CLIP on startup (configurable)
2. **Batch embedding API:** Accept multiple images for efficient inference
3. **systemd drop-in overrides:** Allow operators to tune MemoryMax/CPUQuota without editing unit
4. **Metrics/observability:** Prometheus metrics export (`/metrics` endpoint)
5. **TLS support:** HTTPS with cert configuration
6. **Rate limiting:** Token-bucket rate limiter for QoS
7. **Model caching:** Pre-compute text embeddings for frequent prompts
8. **Multi-model support:** Load/switch between CLIP variants at runtime

## Known Limitations

1. **Slow first request:** Model load on first inference if not pre-loaded (use `--warmup` flag)
2. **No streaming responses:** All embeddings computed before response
3. **Fixed image size:** 224×224; larger images are downsampled
4. **No batch inference:** One image per request (can batch externally)
5. **No TLS:** Assumes reverse proxy for HTTPS if needed

## Monitoring

**Systemd status:**
```bash
systemctl status hailo-clip.service
```

**Logs:**
```bash
journalctl -u hailo-clip.service -f
```

**Resource usage:**
```bash
systemd-cgtop  # Watch memory/CPU for hailo-clip slice
```

**API health:**
```bash
curl http://localhost:5000/health
```
